"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[186],{9875:(e,n,c)=>{c.r(n),c.d(n,{assets:()=>a,contentTitle:()=>i,default:()=>h,frontMatter:()=>t,metadata:()=>r,toc:()=>d});var o=c(4848),s=c(8453);const t={id:"constructs",title:"Constructs",sidebar_position:3},i=void 0,r={id:"api/constructs",title:"Constructs",description:"These functions and objects represent available regex constructs.",source:"@site/docs/api/constructs.md",sourceDirName:"api",slug:"/api/constructs",permalink:"/docs/api/constructs",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{id:"constructs",title:"Constructs",sidebar_position:3},sidebar:"docs",previous:{title:"Builder",permalink:"/docs/api/builder"},next:{title:"Quantifiers",permalink:"/docs/api/quantifiers"}},a={},d=[{value:"<code>choiceOf()</code>",id:"choiceof",level:3},{value:"<code>capture()</code>",id:"capture",level:3},{value:"<code>lookahead()</code>",id:"lookahead",level:3},{value:"<code>negativeLookahead()</code>",id:"negativelookahead",level:3},{value:"<code>lookbehind()</code>",id:"lookbehind",level:3},{value:"<code>negativeLookbehind()</code>",id:"negativelookbehind",level:3}];function l(e){const n={blockquote:"blockquote",code:"code",h3:"h3",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"These functions and objects represent available regex constructs."}),"\n",(0,o.jsx)(n.h3,{id:"choiceof",children:(0,o.jsx)(n.code,{children:"choiceOf()"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"function choiceOf(\n  ...alternatives: RegexSequence[]\n): ChoiceOf {\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Regex syntax: ",(0,o.jsx)(n.code,{children:"a|b|c"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"choiceOf"})," (disjunction) construct matches one out of several possible sequences. It functions similarly to a logical OR operator in programming. It can match simple string options as well as complex patterns."]}),"\n",(0,o.jsxs)(n.p,{children:["Example: ",(0,o.jsx)(n.code,{children:'choiceOf("color", "colour")'})," matches either ",(0,o.jsx)(n.code,{children:"color"})," or ",(0,o.jsx)(n.code,{children:"colour"})," pattern."]}),"\n",(0,o.jsx)(n.h3,{id:"capture",children:(0,o.jsx)(n.code,{children:"capture()"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"function capture(sequence: RegexSequence): Capture;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Regex syntax: ",(0,o.jsx)(n.code,{children:"(...)"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Captures, also known as capturing groups, extract and store parts of the matched string for later use."}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsxs)(n.p,{children:["[!NOTE]\nTS Regex Builder does not have a construct for non-capturing groups. Such groups are implicitly added when required. E.g., ",(0,o.jsx)(n.code,{children:'zeroOrMore(["abc"])'})," is encoded as ",(0,o.jsx)(n.code,{children:"(?:abc)+"}),"."]}),"\n"]}),"\n",(0,o.jsx)(n.h3,{id:"lookahead",children:(0,o.jsx)(n.code,{children:"lookahead()"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"function lookahead(sequence: RegexSequence): Lookahead;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Regex syntax: ",(0,o.jsx)(n.code,{children:"(?=...)"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Allows for conditional matching by checking for subsequent patterns in regexes without consuming them."}),"\n",(0,o.jsx)(n.h3,{id:"negativelookahead",children:(0,o.jsx)(n.code,{children:"negativeLookahead()"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"function negativeLookahead(sequence: RegexSequence): NegativeLookahead;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Regex syntax: ",(0,o.jsx)(n.code,{children:"(?!...)"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Allows for matches to be rejected if a specified subsequent pattern is present, without consuming any characters."}),"\n",(0,o.jsx)(n.h3,{id:"lookbehind",children:(0,o.jsx)(n.code,{children:"lookbehind()"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"function lookbehind(sequence: RegexSequence): Lookahead;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Regex syntax: ",(0,o.jsx)(n.code,{children:"(?<=...)"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Allows for conditional matching by checking for preceeding patterns in regexes without consuming them."}),"\n",(0,o.jsx)(n.h3,{id:"negativelookbehind",children:(0,o.jsx)(n.code,{children:"negativeLookbehind()"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"function negativeLookahead(sequence: RegexSequence): NegativeLookahead;\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Regex syntax: ",(0,o.jsx)(n.code,{children:"(?<!...)"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Allows for matches to be rejected if a specified preceeding pattern is present, without consuming any characters."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,n,c)=>{c.d(n,{R:()=>i,x:()=>r});var o=c(6540);const s={},t=o.createContext(s);function i(e){const n=o.useContext(t);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);